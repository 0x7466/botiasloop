#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../lib/botiasloop"

# Initialize global config instance
Botiasloop::Config.instance = Botiasloop::Config.new

def print_help
  puts "botiasloop - Minimal agentic AI with ReAct loop"
  puts
  puts "Usage: botiasloop [OPTIONS] [COMMAND]"
  puts
  puts "Options:"
  puts "  -h, --help       Show this help message"
  puts "  -v, --version    Show version information"
  puts
  puts "Commands:"
  puts "  cli              Start interactive REPL mode"
  puts "  gateway          Start gateway (Telegram bot and other channels)"
  puts "  help             Show this help message"
  puts
  puts "Gateway Commands:"
  puts "  start            Start the systemd service"
  puts "  stop             Stop the systemd service"
  puts "  restart          Restart the systemd service"
  puts "  status           Show systemd service status"
  puts "  logs             Show service logs (journalctl)"
  puts "  enable           Install and enable systemd service (auto-start on login)"
  puts "  disable          Disable and uninstall systemd service"
  puts
  puts "Logs Options:"
  puts "  -f, --follow     Follow log output in real-time"
  puts "  -n, --lines N    Show last N lines (default: 50)"
end

def start_gateway
  # Check if any channels are configured (excluding CLI)
  available_channels = Botiasloop::Channels.registry.channels.except(:cli)

  if available_channels.empty?
    puts "No gateway channels configured."
    puts "Configure at least one channel (e.g., Telegram) in ~/.config/botiasloop/config.yml"
    exit 1
  end

  manager = Botiasloop::ChannelsManager.new

  # Start all channels and wait
  manager.start_listening.wait
end

if ARGV[0] == "-h" || ARGV[0] == "--help"
  print_help
elsif ARGV[0] == "-v" || ARGV[0] == "--version"
  puts "botiasloop #{Botiasloop::VERSION}"
elsif ARGV[0] == "gateway"
  if ARGV[1] == "start"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.start
        puts "Service started"
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "stop"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.stop
        puts "Service stopped"
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "restart"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.restart
        puts "Service restarted"
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "status"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      status = service.status
      puts "Service status: #{status[:message]}"
      exit(status[:active] ? 0 : 1)
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "logs"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      # Parse logs options
      follow = false
      lines = 50

      # Parse arguments from ARGV[2..] to support both -n 100 and --lines 100 formats
      i = 2
      while i < ARGV.length
        arg = ARGV[i]

        if arg == "-f" || arg == "--follow"
          follow = true
          i += 1
        elsif arg == "-n" || arg == "--lines"
          if i + 1 >= ARGV.length
            puts "Error: #{arg} requires a value"
            exit 1
          end

          lines_str = ARGV[i + 1]
          unless lines_str.match(/^\d+$/)
            puts "Error: Invalid number of lines: #{lines_str}"
            exit 1
          end

          lines = lines_str.to_i
          i += 2
        else
          puts "Unknown option: #{arg}"
          exit 1
        end
      end

      begin
        service.logs(follow: follow, lines: lines)
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "enable"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.install unless service.installed?
        service.enable
        puts "Service installed and enabled. Run 'botiasloop gateway start' to start now."
        puts "The service will start automatically on your next login."
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "disable"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        if service.installed?
          service.uninstall
          puts "Service disabled and uninstalled"
        else
          puts "Service is not installed"
        end
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  else
    start_gateway
  end
elsif ARGV[0] == "cli"
  # CLI interactive mode
  cli_channel = Botiasloop::Channels::CLI.new
  cli_channel.start_listening
elsif ARGV.empty? || ARGV[0] == "help"
  # Default to help when no args or explicit help command
  print_help
else
  # Unknown command
  puts "Unknown command: #{ARGV[0]}"
  puts
  print_help
  exit 1
end
