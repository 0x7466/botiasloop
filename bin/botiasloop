#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../lib/botiasloop"

# Initialize global config instance
Botiasloop::Config.instance = Botiasloop::Config.new

def print_help
  puts "botiasloop - Minimal agentic AI with ReAct loop"
  puts
  puts "Usage: botiasloop [OPTIONS] [COMMAND]"
  puts
  puts "Options:"
  puts "  -h, --help       Show this help message"
  puts "  -v, --version    Show version information"
  puts
  puts "Commands:"
  puts "  cli              Start interactive REPL mode"
  puts "  gateway          Start gateway (Telegram bot and other channels)"
  puts "  help             Show this help message"
  puts
  puts "Gateway Commands:"
  puts "  start            Start the systemd service"
  puts "  stop             Stop the systemd service"
  puts "  restart          Restart the systemd service"
  puts "  status           Show systemd service status"
  puts "  logs             Show service logs (journalctl)"
  puts "  enable           Install and enable systemd service (auto-start on login)"
  puts "  disable          Disable and uninstall systemd service"
  puts
  puts "Agent Commands:"
  puts "  send             Send a prompt to a chat"
  puts
  puts "Logs Options:"
  puts "  -f, --follow     Follow log output in real-time"
  puts "  -n, --lines N    Show last N lines (default: 50)"
end

def agent_send
  args = ARGV[2..]  # Skip "agent" and "send"
  chat_id = nil
  deliver_to_all = false
  prompt = nil

  # First pass: extract all flags
  flag_args = []
  non_flag_args = []
  i = 0
  while i < args.length
    arg = args[i]
    if arg.start_with?("-")
      flag_args << arg
      flag_args << args[i + 1] if args[i + 1] && !args[i + 1].start_with?("-")
      i += args[i + 1] && !args[i + 1].start_with?("-") ? 2 : 1
    else
      non_flag_args << arg
      i += 1
    end
  end

  # Process flag args
  i = 0
  while i < flag_args.length
    arg = flag_args[i]

    case arg
    when "--chat-id"
      if i + 1 >= flag_args.length
        puts "Error: --chat-id requires a value"
        exit 1
      end
      chat_id = flag_args[i + 1].to_i
      i += 2
    when "--deliver-to-all-chats"
      deliver_to_all = true
      i += 1
    when "-h", "--help"
      puts <<~HELP
        Usage: botiasloop agent send [OPTIONS] <prompt>

        Send a prompt to a chat and get a response.

        Options:
          --chat-id ID              Deliver response to specific chat (by chat.id)
          --deliver-to-all-chats    Deliver response to all chats
          -h, --help                Show this help message

        Examples:
          botiasloop agent send "check server status" --chat-id 1
          botiasloop agent send "check server status" --deliver-to-all-chats
      HELP
      exit 0
    else
      i += 1
    end
  end

  # Remaining args are the prompt
  prompt = non_flag_args.join(" ")

  if prompt.nil? || prompt.empty?
    puts "Error: Prompt is required"
    exit 1
  end

  if !chat_id && !deliver_to_all
    puts "Error: Either --chat-id or --deliver-to-all-chats is required"
    exit 1
  end

  if chat_id && deliver_to_all
    $stderr.puts "Error: Cannot use both --chat-id and --deliver-to-all-chats"
    exit 1
  end

  # Get chats to send to
  chats = if deliver_to_all
    # Get all non-CLI chats (CLI should never be used in agent send)
    Botiasloop::Chat.all.reject { |c| c.channel == "cli" }
  else
    chat = Botiasloop::Chat[chat_id]
    unless chat
      $stderr.puts "Error: Chat not found: #{chat_id}"
      exit 1
    end

    # Validate chat is not CLI
    if chat.channel == "cli"
      $stderr.puts "Error: Cannot send to CLI chat. Use --deliver-to-all-chats for non-CLI chats or specify a non-CLI chat ID."
      exit 1
    end

    [chat]
  end

  if chats.empty?
    $stderr.puts "Error: No non-CLI chats found to deliver to."
    exit 1
  end

  # Send prompt to each chat
  chats.each do |chat|
    send_prompt_to_chat(chat, prompt)
  end
end

def send_prompt_to_chat(chat, prompt)
  channel_class = Botiasloop::Channels.registry.channels[chat.channel.to_sym]
  unless channel_class
    $stderr.puts "Error: Unknown channel: #{chat.channel}"
    return
  end

  channel = channel_class.new
  conversation = chat.current_conversation

  # Run agent synchronously
  result = nil
  completed = false

  callback = proc { |message| result = message }
  error_callback = proc { |_error| completed = true }
  completion_callback = proc { completed = true }

  Botiasloop::Agent.chat(
    prompt,
    callback: callback,
    error_callback: error_callback,
    completion_callback: completion_callback,
    chat: chat
  )

  # Wait for completion (poll since agent runs in a thread)
  sleep 0.1 until completed

  # Deliver response via channel
  channel.send_message(chat.external_id, result) if result
end

def start_gateway
  # Check if any channels are configured (excluding CLI)
  available_channels = Botiasloop::Channels.registry.channels.except(:cli)

  if available_channels.empty?
    puts "No gateway channels configured."
    puts "Configure at least one channel (e.g., Telegram) in ~/.config/botiasloop/config.yml"
    exit 1
  end

  manager = Botiasloop::ChannelManager.new

  # Start all channels and wait
  manager.start_listening.wait
end

if ARGV[0] == "-h" || ARGV[0] == "--help"
  print_help
elsif ARGV[0] == "-v" || ARGV[0] == "--version"
  puts "botiasloop #{Botiasloop::VERSION}"
elsif ARGV[0] == "gateway"
  if ARGV[1] == "start"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.start
        puts "Service started"
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "stop"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.stop
        puts "Service stopped"
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "restart"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.restart
        puts "Service restarted"
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "status"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      status = service.status
      puts "Service status: #{status[:message]}"
      exit(status[:active] ? 0 : 1)
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "logs"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      # Parse logs options
      follow = false
      lines = 50

      # Parse arguments from ARGV[2..] to support both -n 100 and --lines 100 formats
      i = 2
      while i < ARGV.length
        arg = ARGV[i]

        if arg == "-f" || arg == "--follow"
          follow = true
          i += 1
        elsif arg == "-n" || arg == "--lines"
          if i + 1 >= ARGV.length
            puts "Error: #{arg} requires a value"
            exit 1
          end

          lines_str = ARGV[i + 1]
          unless lines_str.match(/^\d+$/)
            puts "Error: Invalid number of lines: #{lines_str}"
            exit 1
          end

          lines = lines_str.to_i
          i += 2
        else
          puts "Unknown option: #{arg}"
          exit 1
        end
      end

      begin
        service.logs(follow: follow, lines: lines)
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "enable"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        service.install unless service.installed?
        service.enable
        puts "Service installed and enabled. Run 'botiasloop gateway start' to start now."
        puts "The service will start automatically on your next login."
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  elsif ARGV[1] == "disable"
    service = Botiasloop::SystemdService.new
    if service.systemd_available?
      begin
        if service.installed?
          service.uninstall
          puts "Service disabled and uninstalled"
        else
          puts "Service is not installed"
        end
      rescue Botiasloop::SystemdError => e
        puts "Error: #{e.message}"
        exit 1
      end
    else
      puts "Error: systemd is not available on this system"
      exit 1
    end
  else
    start_gateway
  end
elsif ARGV[0] == "cli"
  # CLI interactive mode
  cli_channel = Botiasloop::Channels::CLI.new
  cli_channel.start_listening
elsif ARGV[0] == "agent" && ARGV[1] == "send"
  agent_send
elsif ARGV.empty? || ARGV[0] == "help"
  # Default to help when no args or explicit help command
  print_help
else
  # Unknown command
  puts "Unknown command: #{ARGV[0]}"
  puts
  print_help
  exit 1
end
